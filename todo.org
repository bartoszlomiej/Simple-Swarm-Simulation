TODAY -*- mode: org -*-

* Majors:
  The problems concerning the most important tasks are shown below.

** DONE Timers
   Now it is a high time I create the timers that will allow to go to the phase 2

*** DONE Does # of neighbors change?
    Check periodically number of neighbors
    
   
*** DONE Broadcast message
    Broadcast message of the neighbor's timer value;
    Always propagate only the smallest value obtained

    
*** DONE Problem - how to propagate broadcast from the neighbor that is in the same AS only?
    1. Propagate AS as a member of a tuple Timer
    2. Check if a neighbor that propagates message is in the same AS
       + Actually, it might be much simpler to implement on the real hardware as here
	 I don't care who is sending the message (on the real hardware it probably the lasers will be used;
	 or sth else that could either send more extensive pieces of information)
    
*** DONE The second timer
    Add the second timer in order to synchronize the AS

*** DONE Aggregation changes
    there must be some switch off (after the transition to phase 2 occurs)

    -Solution - The number which can be incremented only -> will indicate the state
    

** TODO Phase 2 - collective movement
   Main problems -> only one leader at time; leader switching; movement detection?

   Good assumption -> order the leader robot to have constant speed!
   
*** TODO Movement detection

*** TODO Collective movement
    The value of the velocity is given in two directions (x, y). As the velocity of the moving neighbor is in fact
    the distance that it travelled in one loop iteration, hence it is equal to the square root of the distance that it has travelled.
    As the robot is chasing the leader (it doesn't copy the same velocity), it tries to approach the leader with about the same velocity.
    Hence, the velocity must be scaled properly. It is known that the distance that the robot needs to travel is equal to the velocity.
    However, there must be calculated the proportions of V_x and V_y. There was used Pitagorean theorem to calculate given proportions.


    ***IDEA***
    The AS should spread the idea about the initial direction of movement - in order to remove confusion with other AS.
    -the initial direction & speed of movement should be given with the timer value.
    More detailed description is available in my notes

**** TODO Leader starts moving
     0. Determine the leader!
     1. Find direction without any obstacles
     2. Go in that direction

**** TODO Follower starts moving

**** TODO Leader switching
     -Signal must be sent if leader cannot move further -> the leader will be chosen again.

**** TODO Initial direction
     -With the timer there should be given the information about the initial direction. All robots will start to move
     in the given direction when timer go down. The robot that don't have any other robots of the same AS in given
     direction becomes a leader.
     -This decrease the confusion with other AS's, as well as the role of the leader 

* Minors:
  Optional todos
  
** DONE Improved collisions
   Robots should move in the random direction after collision (but it should be restricted angle
   -> at most 90 degrees between the point of collision)

** DONE AS improval - if no other member of AS is visible -> create new AS
   Important -> removes the robots that are outside of the given AS
   

** DONE Structure the program
   - extract classes to separet files


** TODO **OPTIONAL**
   If no neighbors of the same AS are being spotted -> go to state 1
   (It should be applied if necessary in function update() of the Robot class)
   -The aim of that is to change the state of the "lost" robots to found another cluster
   
** TODO All collisions should be smooth

** TODO Make the change of speed easy to change
   after stop speed must be multiplied as initially given
   
   
* Other notes:
Notation used:
AS - autonomus system -> represents the cluster of robots

